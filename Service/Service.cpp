#include <chrono>
#include <cstddef>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <filesystem>
#include <linux/limits.h>
#include <signal.h>
#include <string_view>
#include <sys/socket.h>
#include <sys/sysinfo.h>
#include <sys/types.h>
#include <sys/un.h>
#include <thread>
#include <unistd.h>
#include <vector>

#include "Scanner.hpp"
#include "Service.hpp"
#include "SuspiciousStrings.hpp"
#include "../ScannerResponse.hpp"
#include "../SocketName.hpp"


Service::Service() {
    struct sigaction act;
    std::memset(&act, 0, sizeof(struct sigaction));

    act.sa_handler = &HandleSignal;

    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGINT, &act, NULL);

    unlink(socket_name);

    if ((service_fd_ = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        std::perror("socket");
        std::exit(EXIT_FAILURE);
    }

    struct sockaddr_un address;

    std::memset(&address, 0, sizeof(struct sockaddr_un));

    address.sun_family = AF_UNIX;

    strncpy(address.sun_path, socket_name, sizeof(address.sun_path) - 1);

    if (bind(service_fd_, reinterpret_cast<const struct sockaddr*>(&address), sizeof(struct sockaddr_un)) == -1) {
        close(service_fd_);
        std::perror("bind");
        std::exit(EXIT_FAILURE);
    }

    if (listen(service_fd_, SOMAXCONN) == -1) {
        close(service_fd_);
        std::perror("listen");
        std::exit(EXIT_FAILURE);
    }
}


void Service::Run() {
    while (!got_signal_) {
        int client_fd = -1;

        if ((client_fd = accept(service_fd_, nullptr, nullptr)) != -1) {
            connections_.emplace(Service::ProceedRequest, client_fd);
        } else if (!got_signal_) {
            std::perror("accept");
            break;
        }
    }

    shutdown(service_fd_, SHUT_RDWR);
    close(service_fd_);
    unlink(socket_name);

    while (!connections_.empty()) {
        connections_.front().join();
        connections_.pop();
    }
}


void Service::ProceedRequest(int client_fd) {
    char pathname[PATH_MAX + 1];
    int pathlen = 0;
    if ((pathlen = read(client_fd, pathname, PATH_MAX)) == -1) {
        close(client_fd);
        std::perror("read");
        return;
    }

    auto begin = std::chrono::high_resolution_clock::now();

    pathname[pathlen] = '\0';

    std::vector<std::filesystem::path> files;

    try {
        for (auto& entry : std::filesystem::recursive_directory_iterator(pathname)) {
            if (entry.is_regular_file()) {
                files.push_back(entry.path());
            }
        }
    } catch (const std::filesystem::filesystem_error& e) {
        std::fputs(e.what(), stderr);
        close(client_fd);
    }

    int nprocs = get_nprocs();

    AtomicStats stats;

    std::vector<std::thread> scanners;

    for (int i = 0; i < nprocs; ++i) {
        scanners.emplace_back(Service::ProceedFiles, &files, &stats, i, nprocs);
    }

    for (auto& scanner : scanners) {
        scanner.join();
    }

    auto end = std::chrono::high_resolution_clock::now();

    auto exection_time = std::chrono::duration_cast<std::chrono::seconds>(end - begin).count();

    ScannerResponse res{
        files.size(),
        stats.js_detects.load(),
        stats.unix_detects.load(),
        stats.macos_detects.load(),
        stats.errors.load(),
        static_cast<std::size_t>(exection_time)
    };

    if (write(client_fd, reinterpret_cast<void*>(&res), sizeof(res)) != sizeof(res)) {
        close(client_fd);
        std::perror("write");
        return;
    }

    shutdown(client_fd, SHUT_RDWR);
    close(client_fd);
}


void Service::ProceedFiles(std::vector<std::filesystem::path>* files, AtomicStats* stats, int start_index, int step) {
    Scanner all_sus({unix_sus, macos_sus, js_sus});

    Scanner without_js_sus({unix_sus, macos_sus});

    for (int i = start_index; i < files->size(); i += step) {
        auto path = (*files)[i];
        FILE* f = nullptr;

        if ((f = std::fopen(path.c_str(), "r")) == nullptr) {
            stats->errors.fetch_add(1);
        } else {
            auto [detected, index] = (path.extension() == ".js") ? all_sus.FindFirstMatchIn(f) : without_js_sus.FindFirstMatchIn(f);

            if (detected) {
                if (index == 0) {
                    stats->unix_detects.fetch_add(1);
                } else if (index == 1) {
                    stats->macos_detects.fetch_add(1);
                } else {
                    stats->js_detects.fetch_add(1);
                }
            }
            std::fclose(f);
        }
    }
}

